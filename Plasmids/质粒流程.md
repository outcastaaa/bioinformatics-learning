# Classifying Plasmids

[TOC levels=1-3]: # ""

- [Classifying Plasmids](#classifying-plasmids)
  - [NCBI RefSeq](#ncbi-refseq)
  - [MinHash to get non-redundant plasmids](#minhash-to-get-non-redundant-plasmids)
  - [Grouping by MinHash](#grouping-by-minhash)
  - [Plasmid: prepare](#plasmid-prepare)
  - [Plasmid: run](#plasmid-run)


## NCBI RefSeq
1. 下载raw数据  

```bash
mkdir -p /mnt/d/plasmid
cd /mnt/d/plasmid/data

rsync -avP ftp.ncbi.nlm.nih.gov::refseq/release/plasmid/ RefSeq/
# -a 这是归档模式，表示以递归方式传输文件，并保持所有属性，它等同于-r、-l、-p、-t、-g、-o、-D 选项。-a 选项后面可以跟一个 --no-OPTION，表示关闭 -r、-l、-p、-t、-g、-o、-D 中的某一个，比如-a --no-l 等同于 -r、-p、-t、-g、-o、-D 选项。   
# -v  表示打印一些信息，比如文件列表、文件数量等。
# -P  显示文件传输的进度信息。(实际上"-P"="--partial --progress"，其中的"--progress"才是显示进度信息的)。
# 使用 wget 下载，常常出现压缩包损坏的情况

```


RefSeq 是具有生物意义上的非冗余的基因和蛋白质序列。  
进程：
```bash
Welcome to the NCBI rsync server.


receiving incremental file list
created directory RefSeq
plasmid.10.genomic.gbff.gz
     80,758,532 100%    7.89MB/s    0:00:09 (xfr#1, to-chk=0/1)

sent 43 bytes  received 80,778,363 bytes  4,366,400.32 bytes/sec
total size is 80,758,532  speedup is 1.00
```
本`ftp.ncbi.nlm.nih.gov::refseq/release/plasmid/`页面内容:    

![tu1](../Plasmids/pictures/1.png)  

* FNA：具有FNA 文件扩展名的文件是FASTA格式DNA和蛋白质序列比对文件，其存储可被分子生物学软件使用的DNA信息。FNA文件具体可用于保存核酸信息，而其他FASTA格式包含其他DNA相关信息，如FASTA，FAS，FA，FFN，FAA，FRN，MPFA，SEQ，NET或AA文件扩展名。  
* gbff：GBFF是GenBank数据库的基本信息单位。GBFF序列文件由单个的序列条目组成。序列条目由字段组成，每个字段由关键字起始，后面为该字段的具体说明。字段分若干次子字段，以次关键字或特性表说明符开始。每个序列条目以双斜杠“//*作结束标记




2. 处理gbff文件  

```
cd /mnt/d/plasmid/data/
ggzip -dcf RefSeq/*.genomic.gbff.gz > genomic.gbff
# 对genome内容解压，全部*.genomic.gbff.gz都解压到一个文件中  
# gzip -d 解开压缩文件； -c 把压缩后的文件输出到标准输出设备，不去更动原始文件; -f 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。


perl ~/Scripts/withncbi/taxon/gb_taxon_locus.pl genomic.gbff > refseq_id_seq.csv
# 从NCBI下载的注释文件通常是gbff格式的，而我们平时做上游分析用到的大多数为gff或gtf文件,将gbff转化为gff
# Locus (基因座)，又称座位。基因在染色体上所占的位置。在分子水平上，是有遗传效应的DNA序列。一个基因座可以是一个基因，一个基因的一部分，或具有某种调控作用的DNA序列。

rm genomic.gbff
```

3. genomic.fna 文件: FNA 文件是FASTA格式DNA和蛋白质序列比对文件，其存储可被分子生物学软件使用的DNA信息
```
gzip -dcf RefSeq/plasmid.1.1.genomic.fna.gz |
    grep "^>" |
    head -n 5
# 筛选出该文件中文件名称的前五行

#>NZ_D13972.1 Synechococcus sp. PCC 7002 strain PR-6 plasmid Plasmid pAQ1, complete sequence
>NZ_Y18549.1 Escherichia coli strain K5533 plasmid pColK-JA533, complete sequence
>NZ_U51470.1 Pasteurella multocida plasmid unnamed, complete sequence
>NZ_M10917.1 Bacillus thuringiensis plasmid unnamed, complete sequence
>NZ_U40997.1 Listeria monocytogenes strain BM4293 plasmid pIP823, complete sequence

faops n50 -S -C RefSeq/*.genomic.fna.gz
#N50     209488
#S       4158684992     -S 计算所有条目的大小总和
#C       43857          -C 计算条目数
   
gzip -dcf RefSeq/*.genomic.fna.gz > RefSeq/plasmid.fa

```
###  补充： 

1. ~/Scripts/withncbi/taxon/gb_taxon_locus.pl 内容：  

```
if ( !$file ) {
    die "You should provide a .gb file.\n";
}
elsif ( !-e $file ) {
    die "[$file] doesn't exist.\n";
}

$file = path($file);

my $content = $file->slurp;

my @gbs = grep {/\S+/} split( /^\/\//m, $content );

printf STDERR "There are [%d] sequences.\n", scalar @gbs;
```

2. 对比两个文件是否相同
```
diff file1.gbff.gff file2.gbff.gff  -q -y -W 50 > diff.txt
```
3.  taxon
在生物学中，分类单元taxon（从分类学中反向形成，复数分类群）是由一个或多个生物种群组成的群体，或分类学家看到的生物体形成一个单元。

4. refseq_id_seq.csv 内容：
```
158836	NZ_CP071010
158836	NZ_CP071022
158836	NZ_CP071016
158836	NZ_CP071018
158836	NZ_CP071026
488447	NZ_CP092854
1405	NZ_CP092834
1405	NZ_CP092835
1405	NZ_CP092836

```


4. genomic.gbff内容：  

```
 cat genomic.gbff |  head -n 60
LOCUS       NZ_CP071010           337179 bp    DNA     circular CON 11-MAR-2022
DEFINITION  Enterobacter hormaechei strain RIVM_C034192 plasmid
            pRIVM_C034192_1, complete sequence.
ACCESSION   NZ_CP071010
VERSION     NZ_CP071010.1
DBLINK      BioProject: PRJNA224116
            BioSample: SAMN17615676
            Assembly: GCF_017161605.1
KEYWORDS    RefSeq.
SOURCE      Enterobacter hormaechei
  ORGANISM  Enterobacter hormaechei
            Bacteria; Proteobacteria; Gammaproteobacteria; Enterobacterales;
            Enterobacteriaceae; Enterobacter; Enterobacter cloacae complex.
REFERENCE   1  (bases 1 to 337179)
  AUTHORS   Hendrickx,A.P.A., Landman,F., de Haan,A., Witteveen,S., van
            Santen-Verheuvel,M. and Schouls,L.M.
  TITLE     A genetic cluster of multidrug-resistant Enterobacter cloacae
            complex ST78 harboring a plasmid containing blaVIM-1 and mcr-9 in
            the Netherlands
  JOURNAL   Unpublished
REFERENCE   2  (bases 1 to 337179)
  AUTHORS   Hendrickx,A.P.A., Landman,F., de Haan,A., Witteveen,S., van
            Santen-Verheuvel,M. and Schouls,L.M.
  TITLE     Direct Submission
  JOURNAL   Submitted (24-FEB-2021) Bacterial Surveillance and Response,
            National Institute for Public Health and the Environment, Antoni
            van Leeuwenhoeklaan 9, Bilthoven 3721 MA, Netherlands
COMMENT     REFSEQ INFORMATION: The reference sequence is identical to
            CP071010.1.
            The annotation was added by the NCBI Prokaryotic Genome Annotation
            Pipeline (PGAP). Information about PGAP can be found here:
            https://www.ncbi.nlm.nih.gov/genome/annotation_prok/

            ##Genome-Assembly-Data-START##
            Assembly Method        :: Unicycler v. 0.4.4
            Genome Representation  :: Full
            Expected Final Version :: Yes
            Genome Coverage        :: 30x
            Sequencing Technology  :: Oxford Nanopore MiniION
            ##Genome-Assembly-Data-END##

            ##Genome-Annotation-Data-START##
            Annotation Provider               :: NCBI RefSeq
            Annotation Date                   :: 03/11/2022 12:24:48
            Annotation Pipeline               :: NCBI Prokaryotic Genome
                                                 Annotation Pipeline (PGAP)
            Annotation Method                 :: Best-placed reference protein
                                                 set; GeneMarkS-2+
            Annotation Software revision      :: 6.0
            Features Annotated                :: Gene; CDS; rRNA; tRNA; ncRNA;
                                                 repeat_region
            Genes (total)                     :: 4,878
            CDSs (total)                      :: 4,756
            Genes (coding)                    :: 4,675
            CDSs (with protein)               :: 4,675
            Genes (RNA)                       :: 122
            rRNAs                             :: 9, 8, 8 (5S, 16S, 23S)
            complete rRNAs                    :: 9, 8, 8 (5S, 16S, 23S)
            tRNAs                             :: 91
            ncRNAs                            :: 6
```
[参考文章](https://blog.csdn.net/LSD_1943/article/details/125776832)
![tu2](../Plasmids/pictures/2.png)  
```
1、 LOCUS（代码）序列的功能、序列长度、类型、种属来源、录入日期

2、 DEFINITION（说明）所含的生物学意义的总结性描述

3、 ACCESSION（编号）具有唯一性和永久性
https://www.jianshu.com/p/f510c19ea0b2 介绍的很清楚

4、 VERSION（版本号）检索号、版本号

5、 KEYWORDS（关键词）描述序列，“ . ”表示没有任何描述内容

6、 SOURCE（数据来源）序列来源生物的简称，或分子类型
7、 REFERENCE （文献）与该数据有关的参考文献，按发表时间排名

8、 FEATURES（特性表）描述基因和基因的产物，以及与序列相关的生物学特性，其中包括
a. 特性关键词(Feature key) 简要说明功能组的关键词
b. 特性位置(Location) 指明在特性表中的什么地方找到相关特性
c. 限定词(Qualifiers) 相关特性的辅助信息

9、 ORIGIN（碱基排列顺序）类似于FASTA格式给出了所记录的序列
```
* ACCESSION（编号）:  
```
1）AC_***：genomic mixed，一些可供选择的注释的基因组序列，主要用来标记病毒和原核生物；

2）AP_***：protein mixed，AC_标记序列对应的蛋白产物；

3）NC_***：genomic mixed，完整的基因组分子序列，标记的类别包括基因组、染色体、细胞器、质粒；

4）NG_***：genomic mixed，不完整的基因组区域，提供NCBI基因组注释途径。比较有代表性有不转录的假基因或者哪些很难自行化注释的基因组簇；

5）NM_***：mRNA mixed，转录组产物序列；成熟mRNA转录本序列；

6）NP_***：protein mixed，蛋白产物；主要是全长转录氨基酸序列，但也有一些只有部分蛋白质的部分氨基酸序列；

7）NR_***：RNA mixed，非编码的转录子序列，包括结构RNAs，假基因转子等；

8）NT_***：genomic automated，BAC或者鸟枪测序法的还未完全注释的测序序列；

9）NW_***：genomic automated，BAC或者鸟枪法测序的还未完全注释的测序序列；

10）NZ_ABCD1234***：genomic automated，收集的各种利用鸟枪法测序的测序计划，ABCD​代表的是计划名称；

11）​XM_***：mRNA automated，转录产物；mRNA来自基因组注释，序列相当于基因组重叠群；

12）XP_***：protein automated，蛋白产物；序列相当于基因组重叠群；

13）XR：RNA automated，转录产物；非编码区来自基因组注释，序列相当于基因组重叠群；

14）YP_***：protein mixed，蛋白产物；不涉及到转录组，主要用来标记细菌、病毒和线粒体；

15）ZP_***：protein automated，蛋白产物​；主要是用电脑自动注释；

16）NS_***：genomic automated，未知生物分子基因组序列。

```

## MinHash to get non-redundant plasmids

```bash
mkdir /mnt/d/plasmid/data/nr
cd /mnt/d/plasmid/data/nr

faops size ../RefSeq/plasmid.fa > refseq.sizes

tsv-filter refseq.sizes --le 2:2000 | wc -l
#2473

faops some ../RefSeq/plasmid.fa <(tsv-filter refseq.sizes --gt 2:2000) refseq.fa

cat refseq.fa |
    mash sketch -k 21 -s 1000 -i -p 8 - -o refseq.plasmid.k21s1000.msh

# split
mkdir -p job
faops size refseq.fa |
    cut -f 1 |
    split -l 1000 -a 3 -d - job/

find job -maxdepth 1 -type f -name "[0-9]??" | sort |
    parallel -j 4 --line-buffer '
        echo >&2 "==> {}"
        faops some refseq.fa {} stdout |
            mash sketch -k 21 -s 1000 -i -p 6 - -o {}.msh
    '

find job -maxdepth 1 -type f -name "[0-9]??" | sort |
    parallel -j 4 --line-buffer '
        echo >&2 "==> {}"
        mash dist -p 6 {}.msh refseq.plasmid.k21s1000.msh > {}.tsv
    '

# distance < 0.01
find job -maxdepth 1 -type f -name "[0-9]??" | sort |
    parallel -j 16 '
        cat {}.tsv |
            tsv-filter --ff-str-ne 1:2 --le 3:0.01
    ' \
    > redundant.tsv

head -n 5 redundant.tsv
#NZ_CP034776.1   NC_005249.1     0.000730741     0       970/1000
#NZ_CP034416.1   NC_005249.1     0.00580821      0       794/1000
#NZ_LR745046.1   NC_005249.1     0.0010072       0       959/1000
#NZ_LR745043.1   NC_005249.1     0.000656154     0       973/1000
#NZ_CP033694.1   NC_006323.1     0.00766986      0       741/1000

cat redundant.tsv | wc -l
# 129384

cat redundant.tsv |
    perl -nla -F"\t" -MGraph::Undirected -e '
        BEGIN {
            our $g = Graph::Undirected->new;
        }

        $g->add_edge($F[0], $F[1]);

        END {
            for my $cc ( $g->connected_components ) {
                print join qq{\t}, sort @{$cc};
            }
        }
    ' \
    > connected_components.tsv

cat connected_components.tsv |
    perl -nla -F"\t" -e 'printf qq{%s\n}, $_ for @F' \
    > components.list

wc -l connected_components.tsv components.list
#  2073 connected_components.tsv
#  9800 components.list

faops some -i refseq.fa components.list stdout > refseq.nr.fa
faops some refseq.fa <(cut -f 1 connected_components.tsv) stdout >> refseq.nr.fa

rm -fr job

```

## Grouping by MinHash

```bash
mkdir ~/data/plasmid/grouping
cd ~/data/plasmid/grouping

cat ../nr/refseq.nr.fa |
    mash sketch -k 21 -s 1000 -i -p 8 - -o refseq.nr.k21s1000.msh

# split
mkdir -p job
faops size ../nr/refseq.nr.fa |
    cut -f 1 |
    split -l 1000 -a 3 -d - job/

find job -maxdepth 1 -type f -name "[0-9]??" | sort |
    parallel -j 4 --line-buffer '
        echo >&2 "==> {}"
        faops some ../nr/refseq.nr.fa {} stdout |
            mash sketch -k 21 -s 1000 -i -p 6 - -o {}.msh
    '

find job -maxdepth 1 -type f -name "[0-9]??" | sort |
    parallel -j 4 --line-buffer '
        echo >&2 "==> {}"
        mash dist -p 6 {}.msh refseq.nr.k21s1000.msh > {}.tsv
    '

find job -maxdepth 1 -type f -name "[0-9]??" | sort |
    parallel -j 1 '
        cat {}.tsv
    ' \
    > dist_full.tsv

# distance < 0.05
cat dist_full.tsv |
    tsv-filter --ff-str-ne 1:2 --le 3:0.05 \
    > connected.tsv

head -n 5 connected.tsv
#NC_019347.1     NC_000906.2     0.0321972       0       341/1000
#NC_004847.1     NC_000906.2     0.0458408       0       236/1000
#NC_002111.1     NC_002130.1     0.0375603       0       294/1000
#NC_002636.1     NC_006994.1     0.0284057       0       380/1000
#NC_002524.1     NC_006994.1     0.0444041       0       245/1000

cat connected.tsv | wc -l
#60618

mkdir -p group
cat connected.tsv |
    perl -nla -F"\t" -MGraph::Undirected -MPath::Tiny -e '
        BEGIN {
            our $g = Graph::Undirected->new;
        }

        $g->add_edge($F[0], $F[1]);

        END {
            my @rare;
            my $serial = 1;
            my @ccs = $g->connected_components;
            @ccs = map { $_->[0] }
                sort { $b->[1] <=> $a->[1] }
                map { [ $_, scalar( @{$_} ) ] } @ccs;
            for my $cc ( @ccs ) {
                my $count = scalar @{$cc};
                if ($count < 50) {
                    push @rare, @{$cc};
                }
                else {
                    path(qq{group/$serial.lst})->spew(map {qq{$_\n}} @{$cc});
                    $serial++;
                }
            }
            path(qq{group/00.lst})->spew(map {qq{$_\n}} @rare);

            path(qq{grouped.lst})->spew(map {qq{$_\n}} $g->vertices);
        }
    '

# get non-grouped
# this will no be divided to subgroups
faops some -i ../nr/refseq.nr.fa grouped.lst stdout |
    faops size stdin |
    cut -f 1 \
    > group/lonely.lst

wc -l group/*
#  3333 group/00.lst
#  1644 group/1.lst
#   359 group/2.lst
#    94 group/3.lst
#    69 group/4.lst
#    65 group/5.lst
#    55 group/6.lst
#    51 group/7.lst
#    51 group/8.lst
#  6477 group/lonely.lst
# 12198 total

find group -maxdepth 1 -type f -name "[0-9]*.lst" | sort |
    parallel -j 4 --line-buffer '
        echo >&2 "==> {}"

        faops some ../nr/refseq.nr.fa {} stdout |
            mash sketch -k 21 -s 1000 -i -p 6 - -o {}.msh

        mash dist -p 6 {}.msh {}.msh > {}.tsv
    '

find group -maxdepth 1 -type f -name "[0-9]*.lst.tsv" | sort |
    parallel -j 4 --line-buffer '
        echo >&2 "==> {}"

        cat {} |
            tsv-select -f 1-3 |
            Rscript -e '\''
                library(readr);
                library(tidyr);
                library(ape);
                pair_dist <- read_tsv(file("stdin"), col_names=F);
                tmp <- pair_dist %>%
                    pivot_wider( names_from = X2, values_from = X3, values_fill = list(X3 = 1.0) )
                tmp <- as.matrix(tmp)
                mat <- tmp[,-1]
                rownames(mat) <- tmp[,1]

                dist_mat <- as.dist(mat)
                clusters <- hclust(dist_mat, method = "ward.D2")
                tree <- as.phylo(clusters)
                write.tree(phy=tree, file="{.}.tree.nwk")

                group <- cutree(clusters, h=0.2) # k=3
                groups <- as.data.frame(group)
                groups$ids <- rownames(groups)
                rownames(groups) <- NULL
                groups <- groups[order(groups$group), ]
                write_tsv(groups, "{.}.groups.tsv")
            '\''
    '

# subgroup
mkdir -p subgroup
cp group/lonely.lst subgroup/

find group -name "*.groups.tsv" | sort |
    parallel -j 1 -k '
        cat {} | sed -e "1d" | xargs -I[] echo "{/.}_[]"
    ' |
    sed -e 's/.lst.groups_/_/' |
    perl -na -F"\t" -MPath::Tiny -e '
        path(qq{subgroup/$F[0].lst})->append(qq{$F[1]});
    '

# ignore small subgroups
find subgroup -name "*.lst" | sort |
    parallel -j 1 -k '
        lines=$(cat {} | wc -l)

        if (( lines < 5 )); then
            echo -e "{}\t$lines"
            cat {} >> subgroup/lonely.lst
            rm {}
        fi
    '

# append ccs
cat ../nr/connected_components.tsv |
    parallel -j 1 --colsep "\t" '
        file=$(rg -F -l  "{1}" subgroup)
        echo {} | tr "[:blank:]" "\n" >> ${file}
    '

# remove duplicates
find subgroup -name "*.lst" | sort |
    parallel -j 1 '
        cat {} | sort | uniq > tmp.lst
        mv tmp.lst {}
    '

wc -l subgroup/* |
    sort -nr |
    head -n 100

wc -l subgroup/* |
    perl -pe 's/^\s+//' |
    tsv-filter -d" " --le 1:10 |
    wc -l
#132

wc -l subgroup/* |
    perl -pe 's/^\s+//' |
    tsv-filter -d" " --ge 1:50 |
    tsv-filter -d " " --regex '2:\d+' |
    sort -nr \
    > next.tsv

wc -l next.tsv
#53

# rm -fr job

```

## Plasmid: prepare

* Split sequences

```bash
mkdir ~/data/plasmid/GENOMES
mkdir ~/data/plasmid/taxon

cd ~/data/plasmid/grouping

echo -e "#Serial\tGroup\tCount\tTarget" > ../taxon/group_target.tsv

cat next.tsv |
    cut -d" " -f 2 |
    parallel -j 4 -k --line-buffer '
        echo >&2 "==> {}"

        GROUP_NAME={/.}
        TARGET_NAME=$(head -n 1 {} | perl -pe "s/\.\d+//g")

        SERIAL={#}
        COUNT=$(cat {} | wc -l)

        echo -e "${SERIAL}\t${GROUP_NAME}\t${COUNT}\t${TARGET_NAME}" >> ../taxon/group_target.tsv

        faops order ../nr/refseq.fa {} stdout |
            faops filter -s stdin stdout \
            > ../GENOMES/${GROUP_NAME}.fa
    '

cat next.tsv |
    cut -d" " -f 2 |
    parallel -j 4 -k --line-buffer '
        echo >&2 "==> {}"
        GROUP_NAME={/.}
        faops size ../GENOMES/${GROUP_NAME}.fa > ../taxon/${GROUP_NAME}.sizes
    '

# Optional: RepeatMasker
#egaz repeatmasker -p 16 ../GENOMES/*.fa -o ../GENOMES/

# split-name
find ../GENOMES -maxdepth 1 -type f -name "*.fa" | sort |
    parallel -j 4 '
        faops split-name {} {.}
    '

# mv to dir of basename
find ../GENOMES -maxdepth 2 -mindepth 2 -type f -name "*.fa" | sort |
    parallel -j 4 '
        mkdir -p {.}
        mv {} {.}
    '

```

* `prepseq`

```bash
cd ~/data/plasmid/

cat taxon/group_target.tsv |
    sed -e '1d' |
    parallel --colsep '\t' --no-run-if-empty --linebuffer -k -j 4 '
        echo -e "==> Group: [{2}]\tTarget: [{4}]\n"

        for name in $(cat taxon/{2}.sizes | cut -f 1); do
            egaz prepseq GENOMES/{2}/${name}
        done
    '

```

* Check outliers of lengths

```bash
cd ~/data/plasmid/

cat taxon/*.sizes | cut -f 1 | wc -l
#4816

cat taxon/*.sizes | cut -f 2 | paste -sd+ | bc
#466119084

cat taxon/group_target.tsv |
    sed -e '1d' |
    parallel --colsep '\t' --no-run-if-empty --linebuffer -k -j 4 '
        echo -e "==> Group: [{2}]\tTarget: [{4}]"

        median=$(cat taxon/{2}.sizes | datamash median 2)
        mad=$(cat taxon/{2}.sizes | datamash mad 2)
        lower_limit=$( bc <<< " (${median} - 2 * ${mad}) / 2" )

#        echo $median $mad $lower_limit
        lines=$(tsv-filter taxon/{2}.sizes --le "2:${lower_limit}" | wc -l)

        if (( lines > 0 )); then
            echo >&2 "    $lines lines to be filtered"
            tsv-join taxon/{2}.sizes -e -f <(
                    tsv-filter taxon/{2}.sizes --le "2:${lower_limit}"
                ) \
                > taxon/{2}.filtered.sizes
            mv taxon/{2}.filtered.sizes taxon/{2}.sizes
        fi
    '

cat taxon/*.sizes | cut -f 1 | wc -l
#4780

cat taxon/*.sizes | cut -f 2 | paste -sd+ | bc
#464908146

```

* Rsync to hpcc

```bash
rsync -avP \
    ~/data/plasmid/ \
    wangq@202.119.37.251:data/plasmid

# rsync -avP wangq@202.119.37.251:data/plasmid/ ~/data/plasmid

```

## Plasmid: run

```bash
cd ~/data/plasmid/

cat taxon/group_target.tsv |
    sed -e '1d' | grep "^53" |
    parallel --colsep '\t' --no-run-if-empty --linebuffer -k -j 1 '
        echo -e "==> Group: [{2}]\tTarget: [{4}]\n"

        egaz template \
            GENOMES/{2}/{4} \
            $(cat taxon/{2}.sizes | cut -f 1 | grep -v -x "{4}" | xargs -I[] echo "GENOMES/{2}/[]") \
            --multi -o groups/{2}/ \
            --order \
            --parallel 24 -v

#        bash groups/{2}/1_pair.sh
#        bash groups/{2}/3_multi.sh

        bsub -q mpi -n 24 -J "{2}-1_pair" "bash groups/{2}/1_pair.sh"
        bsub -w "ended({2}-1_pair)" \
            -q mpi -n 24 -J "{2}-3_multi" "bash groups/{2}/3_multi.sh"
    '

# clean
find groups -mindepth 1 -maxdepth 3 -type d -name "*_raw" | parallel -r rm -fr
find groups -mindepth 1 -maxdepth 3 -type d -name "*_fasta" | parallel -r rm -fr
find . -mindepth 1 -maxdepth 3 -type f -name "output.*" | parallel -r rm

echo \
    $(find groups -mindepth 1 -maxdepth 1 -type d | wc -l) \
    $(find groups -mindepth 1 -maxdepth 3 -type f -name "*.nwk.pdf" | wc -l)

```

